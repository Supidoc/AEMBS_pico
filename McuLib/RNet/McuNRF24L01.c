/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : McuNRF24L01.c
**     Component   : nRF24L01
**     Version     : Component 01.103, Driver 01.00, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2021-07-06, 16:35, # CodeGen: 0
**     Abstract    :
**         This component implements a driver for the Nordic Semiconductor nRF24L01 2.4 GHz transceiver.
**     Settings    :
**     Contents    :
**         ConfigureSPI               - void McuNRF24L01_ConfigureSPI(void);
**         WriteRegister              - void McuNRF24L01_WriteRegister(uint8_t reg, uint8_t val);
**         ReadRegister               - uint8_t McuNRF24L01_ReadRegister(uint8_t reg);
**         ReadRegisterData           - void McuNRF24L01_ReadRegisterData(uint8_t reg, uint8_t *buf, uint8_t bufSize);
**         WriteRegisterData          - void McuNRF24L01_WriteRegisterData(uint8_t reg, uint8_t *buf, uint8_t bufSize);
**         WriteRead                  - uint8_t McuNRF24L01_WriteRead(uint8_t val);
**         Write                      - void McuNRF24L01_Write(uint8_t val);
**         GetStatus                  - uint8_t McuNRF24L01_GetStatus(void);
**         GetStatusClrIRQ            - uint8_t McuNRF24L01_GetStatusClrIRQ(void);
**         ResetStatusIRQ             - void McuNRF24L01_ResetStatusIRQ(uint8_t flags);
**         TxPayload                  - void McuNRF24L01_TxPayload(uint8_t *payload, uint8_t payloadSize);
**         RxPayload                  - void McuNRF24L01_RxPayload(uint8_t *payload, uint8_t payloadSize);
**         StopRxTx                   - void McuNRF24L01_StopRxTx(void);
**         StartRxTx                  - void McuNRF24L01_StartRxTx(void);
**         EnableAutoAck              - uint8_t McuNRF24L01_EnableAutoAck(uint8_t pipes);
**         SetStaticPipePayload       - uint8_t McuNRF24L01_SetStaticPipePayload(uint8_t pipe, uint8_t payloadBytes);
**         EnableDynamicPayloadLength - uint8_t McuNRF24L01_EnableDynamicPayloadLength(uint8_t pipeMask);
**         WriteFeature               - uint8_t McuNRF24L01_WriteFeature(uint8_t featureMask);
**         ReadFeature                - uint8_t McuNRF24L01_ReadFeature(uint8_t *featureMask);
**         ReadNofRxPayload           - uint8_t McuNRF24L01_ReadNofRxPayload(uint8_t *nof);
**         ReadObserveTxRegister      - uint8_t McuNRF24L01_ReadObserveTxRegister(uint8_t *nofLoss, uint8_t *nofRetransmitted);
**         ReadReceivedPowerDetector  - uint8_t McuNRF24L01_ReadReceivedPowerDetector(uint8_t *rpd);
**         SetChannel                 - uint8_t McuNRF24L01_SetChannel(uint8_t channel);
**         GetChannel                 - uint8_t McuNRF24L01_GetChannel(uint8_t *channel);
**         ConstantCarrierWave        - uint8_t McuNRF24L01_ConstantCarrierWave(bool turnOn);
**         SetOutputPower             - uint8_t McuNRF24L01_SetOutputPower(int8_t power);
**         GetOutputPower             - uint8_t McuNRF24L01_GetOutputPower(int8_t *power);
**         SetDataRate                - uint8_t McuNRF24L01_SetDataRate(uint16_t rate);
**         GetDataRate                - uint8_t McuNRF24L01_GetDataRate(uint16_t *rate);
**         SetAddressWidth            - uint8_t McuNRF24L01_SetAddressWidth(uint8_t width);
**         GetAddressWidth            - uint8_t McuNRF24L01_GetAddressWidth(uint8_t *pAddrWidth);
**         SetTxAddress               - uint8_t McuNRF24L01_SetTxAddress(uint8_t *address, uint8_t nofAddressBytes);
**         GetTxAddress               - uint8_t McuNRF24L01_GetTxAddress(uint8_t *address, uint8_t nofAddressBytes);
**         SetRxAddress               - uint8_t McuNRF24L01_SetRxAddress(uint8_t pipe, uint8_t *address, uint8_t...
**         GetRxAddress               - uint8_t McuNRF24L01_GetRxAddress(uint8_t pipe, uint8_t *address, uint8_t...
**         GetFifoStatus              - uint8_t McuNRF24L01_GetFifoStatus(uint8_t *status);
**         PollInterrupt              - bool McuNRF24L01_PollInterrupt(void);
**         Deinit                     - void McuNRF24L01_Deinit(void);
**         Init                       - void McuNRF24L01_Init(void);
**
**  * Copyright (c) 2013-2018, 2025, Erich Styger.
**  * nRF channel scanning: Copyright 2025 Nico Zuber who implemented the channel recommendation. Scanning is from https://github.com/htotoo/NRF24ChannelScanner 
**
**  * Web:         https://mcuoneclipse.com
**  * SourceForge: https://sourceforge.net/projects/mcuoneclipse
**  * Git:         https://github.com/ErichStyger/McuOnEclipse_PEx
**  * All rights reserved.
**  *
**  * Redistribution and use in source and binary forms, with or without modification,
**  * are permitted provided that the following conditions are met:
**  *
**  * - Redistributions of source code must retain the above copyright notice, this list
**  *   of conditions and the following disclaimer.
**  *
**  * - Redistributions in binary form must reproduce the above copyright notice, this
**  *   list of conditions and the following disclaimer in the documentation and/or
**  *   other materials provided with the distribution.
**  *
**  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
** ###################################################################*/
/*!
** @file McuNRF24L01.c
** @version 01.00
** @brief
**         This component implements a driver for the Nordic Semiconductor nRF24L01 2.4 GHz transceiver.
*/         
/*!
**  @addtogroup McuNRF24L01_module McuNRF24L01 module documentation
**  @{
*/         

/* MODULE McuNRF24L01. */

#include "McuNRF24L01.h"
#if McuNRF24L01_CONFIG_IS_ENABLED
#include "McuWait.h"
#include "McuSPI.h"
#include "McuGPIO.h"
#include "McuLog.h"
#include "McuUtility.h"

static McuGPIO_Handle_t cePin;  /* CE pin, HIGH active, if active, device is in RX/TX mode */
static McuGPIO_Handle_t csnPin; /* CSN pin, LOW active, used to select device (chip select) to send commands */

/* Macros to hide low level functionality */
#define McuNRF24L01_WAIT_US(x)  McuWait_Waitus(x)          /* wait for the given number of micro-seconds */
#define McuNRF24L01_CE_LOW()    McuGPIO_SetLow(cePin)      /* put CE LOW */
#define McuNRF24L01_CE_HIGH()   McuGPIO_SetHigh(cePin)     /* put CE HIGH */
#define McuNRF24L01_CSN_LOW()   McuGPIO_SetLow(csnPin)     /* put CSN LOW, activate bus */
#define McuNRF24L01_CSN_HIGH()  McuGPIO_SetHigh(csnPin)    /* put CSN HIGH, deactivate bus */

#define McuNRF24L01_USE_SPI_BLOCK_MODE   0                 /* using SPI block read/write */

/* settings for channel scanning */
#define McuNRF24L01_NUM_CHANNELS          (128)  /* nRF24L01+ supports channels 0-127 (2.400-2.525 GHz) */
#define McuNRF24L01_CHANNEL_SCAN_SAMPLES  (200)  /* Number of samples per channel - more samples = better accuracy */

#if 0
static void SM1_Enable(void) {
  /*! \todo */
}

static void SM1_Disable(void) {
  /*! \todo */
}

static int SM1_SetShiftClockPolarity(int pol) {
  /*! \todo */
  return ERR_OK;
}

static int SM1_SetIdleClockPolarity(int pol) {
  /*! \todo */
  return ERR_OK;
}

static int SM1_SetBaudRate(int baud) {
  return McuSPI_SetBaudRate(baud);
}
#endif
#if 0
static int SM1_GetCharsInTxBuf(void) {
  return 0;
}

static int SM1_GetCharsInRxBuf(void) {
  return 1;
}

static int SM1_SendChar(unsigned char ch) {
  return McuSPI_SendByte(ch);
}
#endif
void McuNRF24L01_OnActivate(void) {
#if PL_HAS_SPI
  SPI_OnSPIActivate(SPI_BAUD_INDEX_NRF);
#endif
}

void McuNRF24L01_OnDeactivate(void) {
#if PL_HAS_SPI
  SPI_OnSPIDeactivate(SPI_BAUD_INDEX_NRF);
#endif
}

/* HW SPI */
#define McuNRF24L01_SPI_Enable()                   SM1_Enable()
#define McuNRF24L01_SPI_Disable()                  SM1_Disable()
#define McuNRF24L01_SPI_SetShiftClockPolarity(val) (void)SM1_SetShiftClockPolarity(val)
#define McuNRF24L01_SPI_SetIdleClockPolarity(val)  (void)SM1_SetIdleClockPolarity(val)
#define McuNRF24L01_SPI_GetCharsInTxBuf()          SM1_GetCharsInTxBuf()
#define McuNRF24L01_SPI_GetCharsInRxBuf()          SM1_GetCharsInRxBuf()
#define McuNRF24L01_SPI_SendChar(ch)               SM1_SendChar(ch)
#define McuNRF24L01_SPI_RecvChar(p)                McuSPI_ReceiveByte(p)
#define McuNRF24L01_SPI_SetBaudRateMode(m)         SM1_SetBaudRateMode(m)

#if McuNRF24L01_CONFIG_USE_MUTEX
  #include "McuRTOS.h"

  static SemaphoreHandle_t McuNRF24L01_Mutex = NULL; /* Mutex to allow mutual exclusive access to the bus */
#endif
/* Internal method prototypes */
static uint8_t SPIWriteRead(uint8_t val);
static void SPIWriteReadBuffer(uint8_t *bufOut, uint8_t *bufIn, uint8_t bufSize);
static void SPIWriteBuffer(uint8_t *bufOut, uint8_t bufSize);

/*
** ===================================================================
**     Method      :  ConfigureSPI (component nRF24L01)
**
**     Description :
**         Configures the SPI bus
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void McuNRF24L01_ConfigureSPI(void)
{
#if McuNRF24L01_SWITCH_BUS
  (void)McuNRF24L01_SPI_Disable();
  (void)McuNRF24L01_SPI_SetShiftClockPolarity(0); /* falling edge */
  (void)McuNRF24L01_SPI_SetIdleClockPolarity(0); /* low idle clock polarity */
  (void)McuNRF24L01_SPI_SetBaudRateMode(McuNRF24L01_BAUD_RATE_MODE); /* set bus speed */
  McuSPI_SetBaudRate(baud);
  (void)McuNRF24L01_SPI_Enable();
#endif
}

/*
** ===================================================================
**     Method      :  SPIWriteRead (component nRF24L01)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static uint8_t SPIWriteRead(uint8_t val)
{
  uint8_t ch;
#if 0
  while(McuNRF24L01_SPI_GetCharsInTxBuf()!=0) {} /* wait until tx is empty */
  while(McuNRF24L01_SPI_SendChar(val)!=ERR_OK) {} /* send character */
  while(McuNRF24L01_SPI_GetCharsInTxBuf()!=0) {} /* wait until data has been sent */
  while(McuNRF24L01_SPI_GetCharsInRxBuf()==0) {} /* wait until we receive data */
  while(McuNRF24L01_SPI_RecvChar(&ch)!=ERR_OK) {} /* get data */
#else
  int res = McuSPI_SendReceiveByte(val, &ch);
  if (res!=0) {
    McuLog_fatal("failed SPI send and receive");
  }
#endif
  return ch;
}

/*
** ===================================================================
**     Method      :  SPIWriteReadBuffer (component nRF24L01)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void SPIWriteReadBuffer(uint8_t *bufOut, uint8_t *bufIn, uint8_t bufSize)
{
#if McuNRF24L01_USE_SPI_BLOCK_MODE
  uint16_t snt, rcvd;

  while(McuNRF24L01_SPI_GetCharsInTxBuf()!=0) {} /* wait until tx is empty */
  while(SPI_SendBlock(bufOut, bufSize, &snt)!=ERR_OK) {
    /* send buffer */
  }
  while(McuNRF24L01_SPI_GetCharsInTxBuf()!=0) {} /* wait until data has been sent */
  while(McuNRF24L01_SPI_GetCharsInRxBuf()==0) {} /* wait until we receive data */
  while(SPI_RecvBlock(bufIn, bufSize, &rcvd)!=ERR_OK) {
    /* get data */
  }
#else
  uint8_t i;

  for(i=0;i<bufSize;i++) {
    bufIn[i] = SPIWriteRead(bufOut[i]);
  }
#endif
}

/*
** ===================================================================
**     Method      :  SPIWriteBuffer (component nRF24L01)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void SPIWriteBuffer(uint8_t *bufOut, uint8_t bufSize)
{
#if McuNRF24L01_USE_SPI_BLOCK_MODE
  uint16_t snt, rcvd;
  static uint8_t dummyBuf[SPI_INP_BUF_SIZE];

  if (bufSize>SPI_INP_BUF_SIZE) { /* not enough dummy buffer */
    uint8_t i;

    for(i=0;i<bufSize;i++) {
      (void)SPIWriteRead(bufOut[i]);
    }
  } else {
    while(McuNRF24L01_SPI_GetCharsInTxBuf()!=0) {} /* wait until tx is empty */
    while(SPI_SendBlock(bufOut, bufSize, &snt)!=ERR_OK) {
      /* send buffer */
    }
    while(McuNRF24L01_SPI_GetCharsInTxBuf()!=0) {} /* wait until data has been sent */
    while(McuNRF24L01_SPI_GetCharsInRxBuf()==0) {} /* wait until we receive data */
    while(SPI_SPI.RecvBlock(dummyBuf, bufSize, &rcvd)!=ERR_OK) {
      /* get data */
    }
  }
#else
  uint8_t i;

  for(i=0;i<bufSize;i++) {
    (void)SPIWriteRead(bufOut[i]);
  }
#endif
}

/*
** ===================================================================
**     Method      :  Deinit (component nRF24L01)
**
**     Description :
**         Driver deinitialization
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void McuNRF24L01_Deinit(void)
{
#if McuNRF24L01_CONFIG_USE_MUTEX
  vQueueUnregisterQueue(McuNRF24L01_Mutex);
  vSemaphoreDelete(McuNRF24L01_Mutex);
  McuNRF24L01_Mutex = NULL;
#endif
}

/*
** ===================================================================
**     Method      :  Init (component nRF24L01)
**
**     Description :
**         Initialization method
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
static void InitCS(void) {
  McuGPIO_Config_t config;

  McuNRF24L01_CONFIG_CE_CSN_PIN_PRE_INIT();
  McuGPIO_GetDefaultConfig(&config);

#if McuLib_CONFIG_CPU_IS_ESP32
  config.hw.pin = McuNRF24L01_CONFIG_CE_PIN_NUMBER;
#elif McuLib_CONFIG_CPU_IS_RPxxxx
  config.hw.pin   = McuNRF24L01_CONFIG_CE_PIN_NUMBER;
#else
  config.hw.gpio  = McuNRF24L01_CONFIG_CE_PIN_GPIO;
  config.hw.port  = McuNRF24L01_CONFIG_CE_PIN_PORT;
  config.hw.pin   = McuNRF24L01_CONFIG_CE_PIN_NUMBER;
#endif
  config.isInput = false;
  config.isHighOnInit = false; /* CE is HIGH active */

  cePin = McuGPIO_InitGPIO(&config);
  if (cePin==NULL) {
    McuLog_fatal("failed initializing SPI CE pin");
    for(;;) {} /* error */
  }

#if McuLib_CONFIG_CPU_IS_ESP32
  config.hw.pin = McuNRF24L01_CONFIG_CSN_PIN_NUMBER;
#elif McuLib_CONFIG_CPU_IS_RPxxxx
  config.hw.pin   = McuNRF24L01_CONFIG_CSN_PIN_NUMBER;
#else
  config.hw.gpio  = McuNRF24L01_CONFIG_CSN_PIN_GPIO;
  config.hw.port  = McuNRF24L01_CONFIG_CSN_PIN_PORT;
  config.hw.pin   = McuNRF24L01_CONFIG_CSN_PIN_NUMBER;
#endif
  config.isInput = false;
  config.isHighOnInit = true; /* CSN is LOW active */

  csnPin = McuGPIO_InitGPIO(&config);
  if (csnPin==NULL) {
    McuLog_fatal("failed initializing SPI CSN pin");
    for(;;) {} /* error */
  }
}

void McuNRF24L01_Init(void)
{
#if McuNRF24L01_CONFIG_USE_MUTEX
  #if configSUPPORT_STATIC_ALLOCATION
  static StaticSemaphore_t xMutexBuffer;
  #endif

  #if configSUPPORT_STATIC_ALLOCATION
  McuNRF24L01_Mutex = xSemaphoreCreateRecursiveMutexStatic(&xMutexBuffer);
  #else
  McuNRF24L01_Mutex = xSemaphoreCreateRecursiveMutex();
  #endif
  if (McuNRF24L01_Mutex==NULL) { /* semaphore creation failed */
    for(;;) {} /* error, not enough memory? */
  }
  vQueueAddToRegistry(McuNRF24L01_Mutex, "McuNRF24L01_Mutex");
#endif
  InitCS();
  McuNRF24L01_CE_LOW();   /* CE high: do not send or receive data */
  McuNRF24L01_CSN_HIGH(); /* CSN low: not sending commands to the device */
  McuNRF24L01_ConfigureSPI(); /* set up SPI bus */
}

/*
** ===================================================================
**     Method      :  WriteRegister (component nRF24L01)
**
**     Description :
**         Write a register value to the transceiver
**     Parameters  :
**         NAME            - DESCRIPTION
**         reg             - Register address to write
**         val             - Value to write
**     Returns     : Nothing
** ===================================================================
*/
void McuNRF24L01_WriteRegister(uint8_t reg, uint8_t val)
{
#if McuNRF24L01_CONFIG_USE_MUTEX
  (void)xSemaphoreTakeRecursive(McuNRF24L01_Mutex, portMAX_DELAY);
#endif
#if McuNRF24L01_CONFIG_USE_ON_ACTIVATE_CALLBACK
  McuNRF24L01_CONFIG_ON_ACTIVATE_CALLBACK(); /* call user event */
#endif
#if McuNRF24L01_SWITCH_BUS
  McuNRF24L01_ConfigureSPI(); /* change bus speed */
#endif
  McuNRF24L01_CSN_LOW(); /* initiate command sequence */
  (void)SPIWriteRead(McuNRF24L01_W_REGISTER|reg); /* write register command */
  (void)SPIWriteRead(val); /* write value */
  McuNRF24L01_CSN_HIGH(); /* end command sequence */
#if McuNRF24L01_CONFIG_USE_ON_DEACTIVATE_CALLBACK
  McuNRF24L01_CONFIG_ON_DEACTIVATE_CALLBACK(); /* call user event */
#endif
#if McuNRF24L01_CONFIG_USE_MUTEX
  (void)xSemaphoreGiveRecursive(McuNRF24L01_Mutex);
#endif
  /*lint -save -e522 function lacks side-effects */
  McuNRF24L01_WAIT_US(10); /* insert a delay until next command */
  /*lint -restore */
}

/*
** ===================================================================
**     Method      :  ReadRegister (component nRF24L01)
**
**     Description :
**         Reads a register from the transceiver
**     Parameters  :
**         NAME            - DESCRIPTION
**         reg             - Register address
**     Returns     :
**         ---             - value read
** ===================================================================
*/
uint8_t McuNRF24L01_ReadRegister(uint8_t reg)
{
  uint8_t val;

#if McuNRF24L01_CONFIG_USE_MUTEX
  (void)xSemaphoreTakeRecursive(McuNRF24L01_Mutex, portMAX_DELAY);
#endif
#if McuNRF24L01_CONFIG_USE_ON_ACTIVATE_CALLBACK
  McuNRF24L01_CONFIG_ON_ACTIVATE_CALLBACK(); /* call user event */
#endif
#if McuNRF24L01_SWITCH_BUS
  McuNRF24L01_ConfigureSPI(); /* change bus speed */
#endif
  McuNRF24L01_CSN_LOW();
  (void)SPIWriteRead(reg);
  val = SPIWriteRead(0); /* write dummy */
  McuNRF24L01_CSN_HIGH();
#if McuNRF24L01_CONFIG_USE_ON_DEACTIVATE_CALLBACK
  McuNRF24L01_CONFIG_ON_DEACTIVATE_CALLBACK(); /* call user event */
#endif
#if McuNRF24L01_CONFIG_USE_MUTEX
  (void)xSemaphoreGiveRecursive(McuNRF24L01_Mutex);
#endif
  /*lint -save -e522 function lacks side-effects */
  McuNRF24L01_WAIT_US(10);
  /*lint -restore */
  return val;
}

/*
** ===================================================================
**     Method      :  ReadRegisterData (component nRF24L01)
**
**     Description :
**         Read multiple bytes from the bus.
**     Parameters  :
**         NAME            - DESCRIPTION
**         reg             - Register address
**       * buf             - Pointer to buffer where to store the values
**         bufSize         - Size of the destination buffer
**     Returns     : Nothing
** ===================================================================
*/
void McuNRF24L01_ReadRegisterData(uint8_t reg, uint8_t *buf, uint8_t bufSize)
{
#if McuNRF24L01_CONFIG_USE_MUTEX
  (void)xSemaphoreTakeRecursive(McuNRF24L01_Mutex, portMAX_DELAY);
#endif
#if McuNRF24L01_CONFIG_USE_ON_ACTIVATE_CALLBACK
  McuNRF24L01_CONFIG_ON_ACTIVATE_CALLBACK(); /* call user event */
#endif
#if McuNRF24L01_SWITCH_BUS
  McuNRF24L01_ConfigureSPI(); /* change bus speed */
#endif
  McuNRF24L01_CSN_LOW();
  (void)SPIWriteRead(McuNRF24L01_R_REGISTER|reg);
  SPIWriteReadBuffer(buf, buf, bufSize);
  McuNRF24L01_CSN_HIGH();
#if McuNRF24L01_CONFIG_USE_ON_DEACTIVATE_CALLBACK
  McuNRF24L01_CONFIG_ON_DEACTIVATE_CALLBACK(); /* call user event */
#endif
#if McuNRF24L01_CONFIG_USE_MUTEX
  (void)xSemaphoreGiveRecursive(McuNRF24L01_Mutex);
#endif
  /*lint -save -e522 function lacks side-effects */
  McuNRF24L01_WAIT_US(10);
  /*lint -restore */
}

/*
** ===================================================================
**     Method      :  WriteRegisterData (component nRF24L01)
**
**     Description :
**         Write multiple bytes to the bus.
**     Parameters  :
**         NAME            - DESCRIPTION
**         reg             - Register address
**       * buf             - Pointer to data buffer to write
**         bufSize         - Size of buffer in bytes
**     Returns     : Nothing
** ===================================================================
*/
void McuNRF24L01_WriteRegisterData(uint8_t reg, uint8_t *buf, uint8_t bufSize)
{
#if McuNRF24L01_CONFIG_USE_MUTEX
  (void)xSemaphoreTakeRecursive(McuNRF24L01_Mutex, portMAX_DELAY);
#endif
#if McuNRF24L01_CONFIG_USE_ON_ACTIVATE_CALLBACK
  McuNRF24L01_CONFIG_ON_ACTIVATE_CALLBACK(); /* call user event */
#endif
#if McuNRF24L01_SWITCH_BUS
  McuNRF24L01_ConfigureSPI(); /* change bus speed */
#endif
  McuNRF24L01_CSN_LOW();
  (void)SPIWriteRead(McuNRF24L01_W_REGISTER|reg); /* not masking registers as it would conflict with McuNRF24L01_W_TX_PAYLOAD */
  SPIWriteBuffer(buf, bufSize);
  McuNRF24L01_CSN_HIGH();
#if McuNRF24L01_CONFIG_USE_ON_DEACTIVATE_CALLBACK
  McuNRF24L01_CONFIG_ON_DEACTIVATE_CALLBACK(); /* call user event */
#endif
#if McuNRF24L01_CONFIG_USE_MUTEX
  (void)xSemaphoreGiveRecursive(McuNRF24L01_Mutex);
#endif
  /*lint -save -e522 function lacks side-effects */
  McuNRF24L01_WAIT_US(10);
  /*lint -restore */
}

/*
** ===================================================================
**     Method      :  WriteRead (component nRF24L01)
**
**     Description :
**         Writes a byte and reads back one byte
**     Parameters  :
**         NAME            - DESCRIPTION
**         val             - Value to write to the bus
**     Returns     :
**         ---             - Value read from the bus
** ===================================================================
*/
uint8_t McuNRF24L01_WriteRead(uint8_t val)
{
#if McuNRF24L01_CONFIG_USE_MUTEX
  (void)xSemaphoreTakeRecursive(McuNRF24L01_Mutex, portMAX_DELAY);
#endif
#if McuNRF24L01_CONFIG_USE_ON_ACTIVATE_CALLBACK
  McuNRF24L01_CONFIG_ON_ACTIVATE_CALLBACK(); /* call user event */
#endif
#if McuNRF24L01_SWITCH_BUS
  McuNRF24L01_ConfigureSPI(); /* change bus speed */
#endif
  McuNRF24L01_CSN_LOW();
  val = SPIWriteRead(val);
  McuNRF24L01_CSN_HIGH();
#if McuNRF24L01_CONFIG_USE_ON_DEACTIVATE_CALLBACK
  McuNRF24L01_CONFIG_ON_DEACTIVATE_CALLBACK(); /* call user event */
#endif
#if McuNRF24L01_CONFIG_USE_MUTEX
  (void)xSemaphoreGiveRecursive(McuNRF24L01_Mutex);
#endif
  /*lint -save -e522 function lacks side-effects */
  McuNRF24L01_WAIT_US(10);
  /*lint -restore */
  return val;
}

/*
** ===================================================================
**     Method      :  Write (component nRF24L01)
**
**     Description :
**         Writes a byte to the bus, without returning the byte read.
**     Parameters  :
**         NAME            - DESCRIPTION
**         val             - Value to write
**     Returns     : Nothing
** ===================================================================
*/
void McuNRF24L01_Write(uint8_t val)
{
#if McuNRF24L01_CONFIG_USE_MUTEX
  (void)xSemaphoreTakeRecursive(McuNRF24L01_Mutex, portMAX_DELAY);
#endif
#if McuNRF24L01_CONFIG_USE_ON_ACTIVATE_CALLBACK
  McuNRF24L01_CONFIG_ON_ACTIVATE_CALLBACK(); /* call user event */
#endif
#if McuNRF24L01_SWITCH_BUS
  McuNRF24L01_ConfigureSPI(); /* change bus speed */
#endif
  McuNRF24L01_CSN_LOW();
  (void)SPIWriteRead(val);
  McuNRF24L01_CSN_HIGH();
#if McuNRF24L01_CONFIG_USE_ON_DEACTIVATE_CALLBACK
  McuNRF24L01_CONFIG_ON_DEACTIVATE_CALLBACK(); /* call user event */
#endif
#if McuNRF24L01_CONFIG_USE_MUTEX
  (void)xSemaphoreGiveRecursive(McuNRF24L01_Mutex);
#endif
  /*lint -save -e522 function lacks side-effects */
  McuNRF24L01_WAIT_US(10);
  /*lint -restore */
}

/*
** ===================================================================
**     Method      :  GetStatus (component nRF24L01)
**
**     Description :
**         Returns the device status byte
**     Parameters  : None
**     Returns     :
**         ---             - status byte
** ===================================================================
*/
uint8_t McuNRF24L01_GetStatus(void)
{
  return McuNRF24L01_WriteRead(McuNRF24L01_NOP);
}

/*
** ===================================================================
**     Method      :  ResetStatusIRQ (component nRF24L01)
**
**     Description :
**         Reset the given flags mask of status bits
**     Parameters  :
**         NAME            - DESCRIPTION
**         flags           - Flags, one or more of
**                           RF24_STATUS_RX_DR, RF24_STATUS_TX_DS,
**                           RF24_STATUS_MAX_RT
**     Returns     : Nothing
** ===================================================================
*/
void McuNRF24L01_ResetStatusIRQ(uint8_t flags)
{
  McuNRF24L01_WriteRegister(McuNRF24L01_STATUS, flags); /* reset all IRQ in status register */
}

/*
** ===================================================================
**     Method      :  GetStatusClrIRQ (component nRF24L01)
**
**     Description :
**         Returns the device status byte and clears any IRQ bits in
**         the status register.
**     Parameters  : None
**     Returns     :
**         ---             - status byte
** ===================================================================
*/
uint8_t McuNRF24L01_GetStatusClrIRQ(void)
{
  uint8_t status;

#if McuNRF24L01_CONFIG_USE_MUTEX
  (void)xSemaphoreTakeRecursive(McuNRF24L01_Mutex, portMAX_DELAY);
#endif
#if McuNRF24L01_CONFIG_USE_ON_ACTIVATE_CALLBACK
  McuNRF24L01_CONFIG_ON_ACTIVATE_CALLBACK(); /* call user event */
#endif
#if McuNRF24L01_SWITCH_BUS
  McuNRF24L01_ConfigureSPI(); /* change bus speed */
#endif
  McuNRF24L01_CSN_LOW(); /* initiate command sequence */
  status = SPIWriteRead(McuNRF24L01_W_REGISTER|McuNRF24L01_STATUS); /* get status */
  (void)SPIWriteRead(status&(McuNRF24L01_STATUS_RX_DR|McuNRF24L01_STATUS_TX_DS|McuNRF24L01_STATUS_MAX_RT)); /* reset IRQ Bits */
  McuNRF24L01_CSN_HIGH(); /* end command sequence */
#if McuNRF24L01_CONFIG_USE_ON_DEACTIVATE_CALLBACK
  McuNRF24L01_CONFIG_ON_DEACTIVATE_CALLBACK(); /* call user event */
#endif
#if McuNRF24L01_CONFIG_USE_MUTEX
  (void)xSemaphoreGiveRecursive(McuNRF24L01_Mutex);
#endif
  /*lint -save -e522 function lacks side-effects */
  McuNRF24L01_WAIT_US(10); /* insert a delay until next command */
  /*lint -restore */
  return status;
}

/*
** ===================================================================
**     Method      :  TxPayload (component nRF24L01)
**
**     Description :
**         Send the payload to the Tx FIFO and send it
**     Parameters  :
**         NAME            - DESCRIPTION
**       * payload         - Pointer to buffer with payload to
**                           send
**         payloadSize     - Size of payload buffer
**     Returns     : Nothing
** ===================================================================
*/
void McuNRF24L01_TxPayload(uint8_t *payload, uint8_t payloadSize)
{
  McuNRF24L01_Write(McuNRF24L01_FLUSH_TX); /* flush old data */
  McuNRF24L01_WriteRegisterData(McuNRF24L01_W_TX_PAYLOAD, payload, payloadSize); /* write payload */
  McuNRF24L01_CE_HIGH(); /* start transmission */
  /*lint -save -e522 function lacks side effect  */
  McuNRF24L01_WAIT_US(15); /* keep signal high for 15 micro-seconds */
  /*lint -restore */
  McuNRF24L01_CE_LOW();  /* back to normal */
}

void McuNRF24L01_ToggleActivate(void)
{
  /* With specification v2.0, there is the ACTIVATE register */
  McuNRF24L01_Write(McuNRF24L01_ACTIVATE);
  McuNRF24L01_Write(0x73); /* write this number to activate/deactivate */
}

void McuNRF24L01_TxPayloadNoAck(uint8_t *payload, uint8_t payloadSize)
{
  McuNRF24L01_Write(McuNRF24L01_FLUSH_TX); /* flush old data */
  McuNRF24L01_WriteRegisterData(McuNRF24L01_W_TX_PAYLOAD_NO_ACK, payload, payloadSize); /* write payload */
  McuNRF24L01_CE_HIGH(); /* start transmission */
  /*lint -save -e522 function lacks side effect  */
  McuNRF24L01_WAIT_US(15); /* keep signal high for 15 micro-seconds */
  /*lint -restore */
  McuNRF24L01_CE_LOW();  /* back to normal */
}
/*
** ===================================================================
**     Method      :  RxPayload (component nRF24L01)
**
**     Description :
**         Receive the Rx payload from the FIFO and stores it in a
**         buffer.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * payload         - Pointer to the payload buffer
**         payloadSize     - Size of the payload buffer
**     Returns     : Nothing
** ===================================================================
*/
void McuNRF24L01_RxPayload(uint8_t *payload, uint8_t payloadSize)
{
  McuNRF24L01_CE_LOW(); /* need to disable rx mode during reading RX data */
  McuNRF24L01_ReadRegisterData(McuNRF24L01_R_RX_PAYLOAD, payload, payloadSize); /* rx payload */
  McuNRF24L01_CE_HIGH(); /* re-enable rx mode */
}

/*
** ===================================================================
**     Method      :  StopRxTx (component nRF24L01)
**
**     Description :
**         Stops sending or receiving (sets CE pin to LOW).
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void McuNRF24L01_StopRxTx(void)
{
  McuNRF24L01_CE_LOW(); /* disable RX or TX with pulling CE LOW */
}

/*
** ===================================================================
**     Method      :  StartRxTx (component nRF24L01)
**
**     Description :
**         Starts sending or receiving (sets CE pin to HIGH).
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void McuNRF24L01_StartRxTx(void)
{
  McuNRF24L01_CE_HIGH(); /* enabling RX or TX with pulling CE HIGH */
}

/*
** ===================================================================
**     Method      :  SetChannel (component nRF24L01)
**
**     Description :
**         Sets the radio channel (RF_CH register).
**     Parameters  :
**         NAME            - DESCRIPTION
**         channel         - Channel number, valid channel
**                           numbers are 0x0 to 0x7F
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_SetChannel(uint8_t channel)
{
  McuNRF24L01_WriteRegister(McuNRF24L01_RF_CH, channel&0x7F); /* set channel */
  /* need to flush data after channel change */
  McuNRF24L01_Write(McuNRF24L01_FLUSH_RX); /* flush old data */
  McuNRF24L01_Write(McuNRF24L01_FLUSH_TX); /* flush old data */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  GetChannel (component nRF24L01)
**
**     Description :
**         Returns the radio channel (RF_CH register).
**     Parameters  :
**         NAME            - DESCRIPTION
**       * channel         - Pointer to where to store the
**                           channel number.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_GetChannel(uint8_t *channel)
{
  *channel = McuNRF24L01_ReadRegister(McuNRF24L01_RF_CH); /* read channel */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  EnableAutoAck (component nRF24L01)
**
**     Description :
**         Enables Auto-Acknowledgment for the given pipe(s) (RF_EN_AA
**         register).
**     Parameters  :
**         NAME            - DESCRIPTION
**         pipes           - mask of pipes to be enabled (ENAA_P0
**                           to ENAA_P5)
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_EnableAutoAck(uint8_t pipes)
{
  McuNRF24L01_WriteRegister(McuNRF24L01_EN_AA, pipes&McuNRF24L01_EN_AA_ENAA_ALL); /* enable auto acknowledge for the given pipes */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  ReadNofRxPayload (component nRF24L01)
**
**     Description :
**         Returns the number of received payload bytes for the top
**         R_RX_PAYLOAD in the RX FIFO
**     Parameters  :
**         NAME            - DESCRIPTION
**       * nof             - Pointer to where to store the number of
**                           bytes. A return value of 0 means that the
**                           pipe is not used, and if the value is >32
**                           then the data is not valid.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_ReadNofRxPayload(uint8_t *nof)
{
  *nof = McuNRF24L01_ReadRegister(McuNRF24L01_R_RX_PL_WID); /* read number of RX payload for pipe */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  SetStaticPipePayload (component nRF24L01)
**
**     Description :
**         Specifies the static payload for a pipe.
**     Parameters  :
**         NAME            - DESCRIPTION
**         pipe            - Pipe number, 0 to 5
**         payloadBytes    - Number of payload pipes
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_SetStaticPipePayload(uint8_t pipe, uint8_t payloadBytes)
{
  if (pipe > 5) {
    return ERR_FAULT; /* only pipe 0 to 5 allowed */
  }
  if (payloadBytes>32) {
    return ERR_FAULT;
  }
  McuNRF24L01_WriteRegister(McuNRF24L01_RX_PW_P0+pipe, payloadBytes); /* write number of RX payload for pipe */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  EnableDynamicPayloadLength (component nRF24L01)
**
**     Description :
**         Enables dynamic payload length for the give pipes
**     Parameters  :
**         NAME            - DESCRIPTION
**         pipeMask        - Mask of pipes, with 1 for pipe 0,
**                           2 for pipe 1, 4 for pipe 2 and so on.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_EnableDynamicPayloadLength(uint8_t pipeMask)
{
  /* note: dynamic payload requires EN_DPL and ENAA_Px set for the pipe */
  if (pipeMask>0x3F) {
    return ERR_FAULT; /* only pipe 0 to 5 allowed */
  }
  McuNRF24L01_WriteRegister(McuNRF24L01_DYNPD, pipeMask); /* write number of RX payload for pipe */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  WriteFeature (component nRF24L01)
**
**     Description :
**         Writes the FEATURE register
**     Parameters  :
**         NAME            - DESCRIPTION
**         featureMask     - Mask of FEATURE, e.g.
**                           FEATURE_EN_DPL
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_WriteFeature(uint8_t featureMask)
{
  if (featureMask>(McuNRF24L01_FEATURE_EN_DPL|McuNRF24L01_FEATURE_EN_ACK_PAY|McuNRF24L01_FEATURE_EN_DYN_PAY)) {
    return ERR_FAULT; /* mismatch of feature mask */
  }
  McuNRF24L01_WriteRegister(McuNRF24L01_FEATURE, featureMask); /* write number of RX payload for pipe */
  /* rev2 of the silicon needs the ACTIVATE command: check if writing was successful */
  uint8_t readback;
  if (McuNRF24L01_ReadFeature(&readback)!=ERR_OK) { /* read failed? */
    return ERR_FAILED;
  }
  if (readback!=featureMask) { /* what we wrote is not what we read back? */
    McuNRF24L01_ToggleActivate(); /* try to activate it */
    McuNRF24L01_WriteRegister(McuNRF24L01_FEATURE, featureMask); /* write number of RX payload for pipe */
    /* read it back again */
    if (McuNRF24L01_ReadFeature(&readback)!=ERR_OK) { /* read failed? */
      return ERR_FAILED;
    }
    if (readback!=featureMask) {
      return ERR_FAILED;
    }
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  ReadFeature (component nRF24L01)
**
**     Description :
**         Reads the FEATURE register
**     Parameters  :
**         NAME            - DESCRIPTION
**       * featureMask     - Pointer to value of
**                           FEATURE register
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_ReadFeature(uint8_t *featureMask)
{
  *featureMask = McuNRF24L01_ReadRegister(McuNRF24L01_FEATURE); /* read FEATURE register */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  ReadObserveTxRegister (component nRF24L01)
**
**     Description :
**         Reads the OBSERVE_TX register to return the count of loss
**         packets and count of retransmitted packets.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * nofLoss         - Pointer to number of lost packets
**       * nofRetransmitted - Pointer to
**                           number of retransmitted packets
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_ReadObserveTxRegister(uint8_t *nofLoss, uint8_t *nofRetransmitted)
{
  uint8_t val;

  val = McuNRF24L01_ReadRegister(McuNRF24L01_OBSERVE_TX); /* read OBSERVE_TX register */
  *nofLoss = (uint8_t)((val&0xF0)>>4); /* high nibble */
  *nofRetransmitted = (uint8_t)(val&0x0F); /* high nibble */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  ReadReceivedPowerDetector (component nRF24L01)
**
**     Description :
**         Reads the RPD (Received Power Detector) register. 
**     Parameters  :
**         NAME            - DESCRIPTION
**       * rpd             - Pointer to RPD bit. Bit is one for
**                           received power levels above -64 dBm, zero
**                           for less than -64 dBm.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_ReadReceivedPowerDetector(uint8_t *rpd)
{
  *rpd = McuNRF24L01_ReadRegister(McuNRF24L01_RPD); /* read RPD register */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  ConstantCarrierWave (component nRF24L01)
**
**     Description :
**         Put the transceiver into contant carrier wave output for
**         testing. The output power of a radio is a critical factor
**         for achieving wanted range. Output power is also the first
**         test
**     Parameters  :
**         NAME            - DESCRIPTION
**         turnOn          - Set to true to start constant
**                           carrier wave, false to stop it.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_ConstantCarrierWave(bool turnOn)
{
  /* note: RF channel, output power should be set independently */
  uint8_t val;

  if (turnOn) {
    /* Set PWR_UP = 1 and PRIM_RX = 0 in the CONFIG register. */
    McuNRF24L01_WriteRegister(McuNRF24L01_CONFIG, McuNRF24L01_PWR_UP|McuNRF24L01_PRIM_TX);
    /*lint -save -e522 function lacks side effect  */
    McuNRF24L01_WAIT_US(1500); /* Wait 1.5ms PWR_UP->standby */
    /*lint -restore */
    /* In the RF register set:
       - CONT_WAVE = 1.
       - PLL_LOCK = 1.
       - RF_PWR (is set independently)
    */
    val = McuNRF24L01_ReadRegister(McuNRF24L01_RF_SETUP); /* read RF_SETUP register */
    val |= McuNRF24L01_RF_SETUP_CONT_WAVE|McuNRF24L01_RF_SETUP_PLL_LOCK; /* set bits */
    McuNRF24L01_WriteRegister(McuNRF24L01_RF_SETUP, val);
    McuNRF24L01_CE_HIGH(); /* CE is high for carrier transmission */
    /* CE is kept high as long the carrier is needed */
  } else {
    val = McuNRF24L01_ReadRegister(McuNRF24L01_RF_SETUP); /* read RF_SETUP register */
    val &= ~(McuNRF24L01_RF_SETUP_CONT_WAVE|McuNRF24L01_RF_SETUP_PLL_LOCK); /* clear bits */
    McuNRF24L01_WriteRegister(McuNRF24L01_RF_SETUP, val); /* write back value */
    McuNRF24L01_CE_LOW(); /* pull CE Low to disable transceiver */
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  SetOutputPower (component nRF24L01)
**
**     Description :
**         Sets the output power
**     Parameters  :
**         NAME            - DESCRIPTION
**         power           - Output power in dBm, either 0, -10, -12
**                           or -18
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_SetOutputPower(int8_t power)
{
  uint8_t val;

  /* get current register value */
  val = McuNRF24L01_ReadRegister(McuNRF24L01_RF_SETUP); /* read RF_SETUP register */
  val &= ~McuNRF24L01_RF_SETUP_RF_PWR_MASK; /* clear bits */
  if (power==-18) {
    val |= McuNRF24L01_RF_SETUP_RF_PWR_18;
  } else if (power==-12) {
    val |= McuNRF24L01_RF_SETUP_RF_PWR_12;
  } else if (power==-10) {
    val |= McuNRF24L01_RF_SETUP_RF_PWR_10;
  } else if (power==0) {
    val |= McuNRF24L01_RF_SETUP_RF_PWR_0;
  } else {
    return ERR_RANGE;
  }
  McuNRF24L01_WriteRegister(McuNRF24L01_RF_SETUP, val);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  GetOutputPower (component nRF24L01)
**
**     Description :
**         Returns the current output power
**     Parameters  :
**         NAME            - DESCRIPTION
**       * power           - Pointer to where to store the value.
**                           Returns the output power in dBm
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_GetOutputPower(int8_t *power)
{
  uint8_t val;

  val = McuNRF24L01_ReadRegister(McuNRF24L01_RF_SETUP); /* read RF_SETUP register */
  if ((val&McuNRF24L01_RF_SETUP_RF_PWR_MASK)==McuNRF24L01_RF_SETUP_RF_PWR_18) {
    *power = -18;
  } else if ((val&McuNRF24L01_RF_SETUP_RF_PWR_MASK)==McuNRF24L01_RF_SETUP_RF_PWR_12) {
    *power = -12;
  } else if ((val&McuNRF24L01_RF_SETUP_RF_PWR_MASK)==McuNRF24L01_RF_SETUP_RF_PWR_10) {
    *power = -10;
  } else if ((val&McuNRF24L01_RF_SETUP_RF_PWR_MASK)==McuNRF24L01_RF_SETUP_RF_PWR_0) {
    *power = 0;
  } else {
    return ERR_RANGE;
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  SetDataRate (component nRF24L01)
**
**     Description :
**         Sets the data rate
**     Parameters  :
**         NAME            - DESCRIPTION
**         rate            - Data rate, either 250, 1000 or 2000
**                           (kbps)
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_SetDataRate(uint16_t rate)
{
  uint8_t val;

  /* get current register value */
  val = McuNRF24L01_ReadRegister(McuNRF24L01_RF_SETUP); /* read RF_SETUP register */
  val &= ~McuNRF24L01_RF_SETUP_RF_DR_MASK; /* clear bits */
  if (rate==250) {
    val |= McuNRF24L01_RF_SETUP_RF_DR_250;
  } else if (rate==1000) {
    val |= McuNRF24L01_RF_SETUP_RF_DR_1000;
  } else if (rate==2000) {
    val |= McuNRF24L01_RF_SETUP_RF_DR_2000;
  } else { /* illegal parameter */
    return ERR_RANGE;
  }
  McuNRF24L01_WriteRegister(McuNRF24L01_RF_SETUP, val);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  GetDataRate (component nRF24L01)
**
**     Description :
**         Returns the current data rate
**     Parameters  :
**         NAME            - DESCRIPTION
**       * rate            - Pointer to where to store the value.
**                           Returns the data rate, either 250, 1000 or
**                           2000 (kbps)
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_GetDataRate(uint16_t *rate)
{
  uint8_t val;

  val = McuNRF24L01_ReadRegister(McuNRF24L01_RF_SETUP); /* read RF_SETUP register */
  if ((val&McuNRF24L01_RF_SETUP_RF_DR_MASK)==McuNRF24L01_RF_SETUP_RF_DR_250) {
    *rate = 250;
  } else if ((val&McuNRF24L01_RF_SETUP_RF_DR_MASK)==McuNRF24L01_RF_SETUP_RF_DR_1000) {
    *rate = 1000;
  } else if ((val&McuNRF24L01_RF_SETUP_RF_DR_MASK)==McuNRF24L01_RF_SETUP_RF_DR_2000) {
    *rate = 2000;
  } else {
    return ERR_RANGE;
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  PollInterrupt (component nRF24L01)
**
**     Description :
**         If there is no interrupt line available, this method polls
**         the device to check if there is an interrupt. If 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
bool McuNRF24L01_PollInterrupt(void)
{
  /*lint -save -e522 function lacks side effect  */
  uint8_t status;
  bool interrupt = false;
  extern void RADIO_OnInterrupt(void); /* prototype */

  status = McuNRF24L01_GetStatus();
  if (status&(McuNRF24L01_STATUS_RX_DR|McuNRF24L01_STATUS_TX_DS|McuNRF24L01_STATUS_MAX_RT)) {
    McuNRF24L01_CE_LOW(); /* pull CE Low to disable transceiver */
    RADIO_OnInterrupt();
    McuNRF24L01_OnInterrupt(); /* call user event (if enabled)... */
    interrupt = true;
  }
  return interrupt;
  /*lint -restore */
}

/*
** ===================================================================
**     Method      :  GetFifoStatus (component nRF24L01)
**
**     Description :
**         Returns the FIFO_STATUS register value
**     Parameters  :
**         NAME            - DESCRIPTION
**       * status          - Pointer to where to store the FIFO
**                           status value.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_GetFifoStatus(uint8_t *status)
{
  *status = McuNRF24L01_ReadRegister(McuNRF24L01_FIFO_STATUS); /* read FIFO_STATUS register */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  SetAddressWidth (component nRF24L01)
**
**     Description :
**         Sets the address width using the SETUP_AW register
**     Parameters  :
**         NAME            - DESCRIPTION
**         width           - only 3, 4 or 5 is allowed
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_SetAddressWidth(uint8_t width)
{
  if (width==3) {
    McuNRF24L01_WriteRegister(McuNRF24L01_SETUP_AW, McuNRF24L01_SETUP_AW_3BYTES);
  } else if (width==4) {
    McuNRF24L01_WriteRegister(McuNRF24L01_SETUP_AW, McuNRF24L01_SETUP_AW_4BYTES);
  } else if (width==5) {
    McuNRF24L01_WriteRegister(McuNRF24L01_SETUP_AW, McuNRF24L01_SETUP_AW_5BYTES);
  } else {
    return ERR_FAILED; /* only 3, 4 or 5 allowed */
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  GetAddressWidth (component nRF24L01)
**
**     Description :
**         Returns the address width stored in the SETUP_AW register
**     Parameters  :
**         NAME            - DESCRIPTION
**       * pAddrWidth      - Pointer to where to store
**                           the value.
**     Returns     :
**         ---             - number of address bytes (3, 4 or 5)
** ===================================================================
*/
uint8_t McuNRF24L01_GetAddressWidth(uint8_t *pAddrWidth)
{
  uint8_t val;

  val = McuNRF24L01_ReadRegister(McuNRF24L01_SETUP_AW); /* read RF_SETUP_AW register */
  if (val==McuNRF24L01_SETUP_AW_3BYTES) {
    *pAddrWidth = 3;
    return ERR_OK;
  } else if (val==McuNRF24L01_SETUP_AW_4BYTES) {
    *pAddrWidth = 4;
    return ERR_OK;
  } else if (val==McuNRF24L01_SETUP_AW_5BYTES) {
    *pAddrWidth = 5;
    return ERR_OK;
  } else {
    /* failure */
    *pAddrWidth = 0; /* illegal value */
    return ERR_FAILED;
  }
}

/*
** ===================================================================
**     Method      :  SetTxAddress (component nRF24L01)
**
**     Description :
**         Sets the TX address using the RF_TX_ADDR register.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * address         - Pointer to the buffer with the
**                           address bytes.
**         nofAddressBytes - Number of address
**                           bytes and size of buffer, typically 5.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_SetTxAddress(uint8_t *address, uint8_t nofAddressBytes)
{
  int i, j;
  uint8_t swap[5]; /* address is max 5 bytes */

  if (nofAddressBytes>=3 && nofAddressBytes<=5) {
    for(j=0,i=nofAddressBytes-1; i>=0 && j<(int)sizeof(swap); i--,j++) { /* need to send LSB first */
      swap[j] = address[i];
    }
    McuNRF24L01_WriteRegisterData(McuNRF24L01_TX_ADDR, &swap[0], nofAddressBytes);
    return ERR_OK;
  } else {
    return ERR_FAILED; /* only 3, 4 or 5 address bytes allowed */
  }
}

/*
** ===================================================================
**     Method      :  GetTxAddress (component nRF24L01)
**
**     Description :
**         Returns the TX address using the RF_TX_ADDR register.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * address         - Pointer to array where the return
**                           the address bytes.
**         nofAddressBytes - Number of address
**                           bytes and size of buffer, typically 5.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_GetTxAddress(uint8_t *address, uint8_t nofAddressBytes)
{
  int i, j;
  uint8_t swap[5]; /* address is max 5 bytes */

  if (nofAddressBytes>=3 && nofAddressBytes<=5) {
    McuNRF24L01_ReadRegisterData(McuNRF24L01_TX_ADDR, swap, nofAddressBytes);
    for(j=0,i=nofAddressBytes-1; i>=0 && j<nofAddressBytes; i--,j++) {
      address[j] = swap[i];
    }
    return ERR_OK;
  } else {
    return ERR_FAILED; /* only 3, 4 or 5 address bytes allowed */
  }
}

/*
** ===================================================================
**     Method      :  SetRxAddress (component nRF24L01)
**
**     Description :
**         Set the TX address using the RF_RX_ADDR_Px register.
**     Parameters  :
**         NAME            - DESCRIPTION
**         pipe            - pipe number (0-5)
**       * address         - Pointer to array where the return
**                           the address bytes.
**         nofAddressBytes - Number of address
**                           bytes and size of buffer, typically 5.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_SetRxAddress(uint8_t pipe, uint8_t *address, uint8_t nofAddressBytes)
{
  uint8_t swap[5]; /* address is max 5 bytes */
  int i, j;

  if (pipe>5) {
    return ERR_FAILED; /* only pipe 0 to 5 allowed */
  }
  if (!(nofAddressBytes>=3 && nofAddressBytes<=5)) {
    return ERR_FAILED; /* only 3, 4 or 5 allowed */
  }
  if (pipe==0 || pipe==1) { /* full number of address bytes */
    for(j=0,i=nofAddressBytes-1; i>=0 && j<(int)sizeof(swap); i--,j++) { /* need to send LSB first */
      swap[j] = address[i];
    }
    McuNRF24L01_WriteRegisterData(McuNRF24L01_RX_ADDR_P0+pipe, &swap[0], nofAddressBytes);
  } else { /* P2-P5: only last byte */
    McuNRF24L01_WriteRegisterData(McuNRF24L01_RX_ADDR_P0+pipe, &address[nofAddressBytes-1], 1);
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  GetRxAddress (component nRF24L01)
**
**     Description :
**         Returns the RX address using the RF_RX_ADDR_Px register.
**     Parameters  :
**         NAME            - DESCRIPTION
**         pipe            - pipe number (0-5)
**       * address         - Pointer to array where the return
**                           the address bytes.
**         nofAddressBytes - Number of address
**                           bytes and size of buffer, typically 5.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t McuNRF24L01_GetRxAddress(uint8_t pipe, uint8_t *address, uint8_t nofAddressBytes)
{
  int i, j;
  uint8_t swap[5]; /* address is max 5 bytes */

  if (pipe>5) {
    return ERR_FAILED; /* only pipe 0 to 5 allowed */
  }
  if (!(nofAddressBytes>=3 && nofAddressBytes<=5)) {
    return ERR_FAILED; /* only 3, 4 or 5 allowed */
  }
  for(i=0; i<nofAddressBytes; i++) {
    swap[i] = 0; /* init */
  }
  if (pipe==0 || pipe==1) { /* full number of address bytes */
    McuNRF24L01_ReadRegisterData(McuNRF24L01_RX_ADDR_P0+pipe, swap, nofAddressBytes);
  } else if (pipe>=2 && pipe<=5) {
    McuNRF24L01_ReadRegisterData(McuNRF24L01_RX_ADDR_P1, swap, nofAddressBytes); /* read base address from P1 */
    McuNRF24L01_ReadRegisterData(McuNRF24L01_RX_ADDR_P0+pipe, &swap[0], 1); /* pipe 2-5 only have one address byte */
  }
  /* swap back into correct order */
  for(j=0,i=nofAddressBytes-1; i>=0 && j<(int)nofAddressBytes; i--,j++) {
    address[j] = swap[i];
  }
  return ERR_OK;
}

static uint8_t PerformChannelScan(uint8_t *channelData, uint8_t numChannels, uint32_t timeoutMs) {
  /* Multi-round adaptive scanning algorithm
   * Scans all channels repeatedly until:
   * - At least one channel reaches 100% occupancy, OR
   * - Timeout is reached
   * 
   * Each round:
   * - Samples each channel 3 times with RPD (Received Power Detector)
   * - Increments occupancy by 1% per carrier detection (0-3% per round)
   * - Shows progress every 20 rounds with ETA
   */
  
  uint8_t ch;
  uint8_t rpd;
  TickType_t startTime = xTaskGetTickCount();
  uint16_t round = 0;
  bool channelFilled = false;
  
  /* Clear channel data array */
  for (ch = 0; ch < numChannels; ch++) {
    channelData[ch] = 0;
  }
  
  McuLog_info("Scanning RF channels. This might take up to %d seconds...", timeoutMs / 1000);
  
  while (!channelFilled) {
    round++;
    
    /* Check timeout */
    TickType_t elapsed = (xTaskGetTickCount() - startTime) * portTICK_PERIOD_MS;
    if (elapsed >= timeoutMs) {
      McuLog_info("Scan timeout after %d rounds", round);
      break;
    }
    
    /* Scan each channel in this round */
    for (ch = 0; ch < numChannels; ch++) {
      uint8_t carrierCount = 0;
      
      /* Set channel */
      McuNRF24L01_WriteRegister(McuNRF24L01_RF_CH, ch);
      
      /* Enable RX for this channel */
      McuNRF24L01_StartRxTx();
      
      /* Wait for channel to stabilize */
      McuWait_Waitus(200);
      
      /* Take multiple quick samples (3 samples per round) */
      for (uint8_t sample = 0; sample < 3; sample++) {
        /* Read RPD (Received Power Detector) register - bit 0 indicates carrier */
        rpd = McuNRF24L01_ReadRegister(McuNRF24L01_RPD);
        if (rpd & 0x01) {  /* Carrier detected */
          carrierCount++;
        }
        
        /* Short delay between samples */
        McuWait_Waitus(150);
      }
      
      /* Disable RX for this channel before moving to next */
      McuNRF24L01_StopRxTx();
      
      /* Accumulate carrier detections */
      /* Increment by 1% per hit for finer granularity */
      if (carrierCount > 0 && channelData[ch] < 100) {
        channelData[ch] += carrierCount;  /* 1-3% increase per round (1% per hit) */
        if (channelData[ch] >= 100) {
          channelData[ch] = 100;  /* Cap at 100% */
          channelFilled = true;   /* Stop condition met */
        }
      }
    }

    /* Log progress every 20 rounds with highest bin value and estimated time remaining */
    if (round % 20 == 0) {
      /* Find highest filled channel */
      uint8_t maxOccupancy = 0;
      for (ch = 0; ch < numChannels; ch++) {
        if (channelData[ch] > maxOccupancy) {
          maxOccupancy = channelData[ch];
        }
      }
      
      /* Calculate estimated time remaining */
      uint32_t remainingSeconds = 0;
      if (maxOccupancy > 0) {
        /* Estimate rounds needed: (100 - current) / (current / round) */
        uint32_t estimatedTotalRounds = (round * 100) / maxOccupancy;
        uint32_t remainingRounds = estimatedTotalRounds - round;
        /* Each round takes ~elapsed/round ms, convert to seconds */
        remainingSeconds = (remainingRounds * elapsed) / (round * 1000);
        if (remainingSeconds > (timeoutMs - elapsed) / 1000) {
          remainingSeconds = (timeoutMs - elapsed) / 1000;  /* Cap at timeout */
        }
      } else {
        /* No signal yet, assume full timeout */
        remainingSeconds = (timeoutMs - elapsed) / 1000;
      }

      /* Build progress bar string: [####......] 40% ETA: 12s */
      unsigned char progressBuf[64];
      McuUtility_strcpy(progressBuf, sizeof(progressBuf), (unsigned char*)"[");
      
      /* Progress bar: 20 characters wide */
      uint8_t barFilled = (maxOccupancy * 20) / 100;  /* 0-20 filled characters */
      for (uint8_t i = 0; i < 20; i++) {
        if (i < barFilled) {
          McuUtility_strcat(progressBuf, sizeof(progressBuf), (unsigned char*)"#");
        } else {
          McuUtility_strcat(progressBuf, sizeof(progressBuf), (unsigned char*)".");
        }
      }
      
      McuUtility_strcat(progressBuf, sizeof(progressBuf), (unsigned char*)"] ");
      McuUtility_strcatNum8u(progressBuf, sizeof(progressBuf), maxOccupancy);
      McuUtility_strcat(progressBuf, sizeof(progressBuf), (unsigned char*)"%% ETA: ~");
      McuUtility_strcatNum32u(progressBuf, sizeof(progressBuf), remainingSeconds);
      McuUtility_strcat(progressBuf, sizeof(progressBuf), (unsigned char*)" s");
      
      McuLog_info((char*)progressBuf);
    }
  }
  return ERR_OK;
}

static uint8_t ScanChannels(uint8_t *channelData, uint8_t maxChannels) {
  uint8_t numChannels = (maxChannels < McuNRF24L01_NUM_CHANNELS) ? maxChannels : McuNRF24L01_NUM_CHANNELS;
  uint8_t res;
  
  if (channelData == NULL) {
    return ERR_PARAM_ADDRESS;
  }
  
  #if PL_CONFIG_USE_POWER_MANAGER
    PWR_SetComponentState(PWR_COMPONENT_RADIO, PWR_STATE_ACTIVE, true);
  #endif
  
  McuLog_info("Starting channel scan (0-%d)...", numChannels-1);
  
  /* Save current radio state */
  uint8_t originalChannel = McuNRF24L01_ReadRegister(McuNRF24L01_RF_CH);
  uint8_t originalConfig = McuNRF24L01_ReadRegister(McuNRF24L01_CONFIG);
  uint8_t originalRFSetup = McuNRF24L01_ReadRegister(McuNRF24L01_RF_SETUP);
  
  /* Stop radio and configure for scanning */
  McuNRF24L01_StopRxTx();
  
  /* Configure for RX mode: Power up, RX mode, CRC enabled */
  McuNRF24L01_WriteRegister(McuNRF24L01_CONFIG, 
    McuNRF24L01_CONFIG_EN_CRC |        /* Enable CRC */
    McuNRF24L01_CONFIG_CRCO |          /* 2 byte CRC */
    McuNRF24L01_CONFIG_PWR_UP |        /* Power up */
    McuNRF24L01_CONFIG_PRIM_RX);       /* RX mode */
  
  /* Disable auto-acknowledge for scanning */
  McuNRF24L01_WriteRegister(McuNRF24L01_EN_AA, 0x00);
  
  /* Set to highest sensitivity: 
   * - Maximum TX power (not used in RX, but part of default)
   * - Enable LNA (Low Noise Amplifier) for maximum receive sensitivity (bit 0 = 1)
   * - Use configured data rate
   */
  McuNRF24L01_WriteRegister(McuNRF24L01_RF_SETUP, 
    McuNRF24L01_RF_SETUP_RF_PWR_0 | RNET_CONFIG_NRF24_DATA_RATE | 0x01); /* bit 0 = LNA enable */
  
  /* Wait for power up */
  McuWait_Waitms(5);
  
  /* Perform the actual scan with 30 second timeout */
  #define SCAN_TIMEOUT_MS 30000
  res = PerformChannelScan(channelData, numChannels, SCAN_TIMEOUT_MS);
  
  /* Restore original configuration */
  McuNRF24L01_StopRxTx();
  McuNRF24L01_WriteRegister(McuNRF24L01_CONFIG, originalConfig);
  McuNRF24L01_WriteRegister(McuNRF24L01_RF_CH, originalChannel);
  McuNRF24L01_WriteRegister(McuNRF24L01_RF_SETUP, originalRFSetup);
  
  McuLog_info("Channel scan complete");
  return res;
}

static uint8_t FindRecommendedChannels(uint8_t numRecommendations, uint8_t *channelData, uint8_t *recommendedChannels) {
  /* 
   * Channel Recommendation Algorithm
   * ============================================
   * 
   * This algorithm recommends channels across the entire NRF24l01+'s spectrum
   * it aims to maximize separation and avoid existing interference.
   * 
   * Algorithm Steps:
   * 
   * 1. FIND QUIET GAPS:
   *    - Scan spectrum for continuous regions where occupancy is below a certain threshold
   *    - Only consider gaps that are wide enough to be useful
   * 
   * 2. CALCULATE TOTAL USABLE SPECTRUM:
   *    - Sum the widths of all quiet gaps found
   *    - This represents the total "free spectrum" available
   * 
   * 3. PROPORTIONAL DISTRIBUTION:
   *    - Each gap receives channels proportional to its size
   *    - Large gaps receive more channels, small gaps receive fewer
   *    - Example: A large gap representing 45% of free spectrum gets ~40% of channels
   * 
   * 4. HANDLE ROUNDING:
   *    - Integer division may leave some channels unassigned
   *    - Distribute remainder to gaps that have room for more channels
   *    - Ensures all requested channels are assigned if possible
   * 
   * 5. PLACE CHANNELS WITHIN GAPS:
   *    - Single channel: placed in gap center for best isolation
   *    - Multiple channels: evenly distributed from start to end
   *    - Maximizes separation between channels within each gap
   * 
   * 6. FALLBACK STRATEGY:
   *    - If not enough quiet gaps exist, select lowest occupancy channels
   *    - Maintains minimum spacing between channels to avoid interference
   *    - Ensures best possible channel selection even in crowded environments
   */

  /* Configuration constants */
  #define NUM_CHANNELS 126
  #define MIN_CHANNEL_SPACING 3  /* Minimum spacing between channels to avoid interference */
  #define MIN_GAP_WIDTH 5        /* Minimum width of a gap to be considered useful */
  #define OCCUPANCY_THRESHOLD 10 /* Channels below this occupancy % are considered "quiet" */
  
  typedef struct {
    uint8_t start;
    uint8_t end;
    uint8_t width;
    uint8_t avgOccupancy;
    uint8_t channelsAssigned;  /* Number of channels assigned to this gap */
  } Gap_t;
  
  /* Step 1: Find all quiet gaps in the spectrum */
  #define MAX_GAPS 20
  Gap_t gaps[MAX_GAPS];
  uint8_t numGaps = 0;
  
  bool inGap = false;
  uint8_t gapStart = 0;
  uint32_t gapOccupancySum = 0;
  
  for (uint8_t ch = 0; ch < NUM_CHANNELS; ch++) {
    if (channelData[ch] <= OCCUPANCY_THRESHOLD) {
      if (!inGap) {
        /* Start of new gap */
        inGap = true;
        gapStart = ch;
        gapOccupancySum = channelData[ch];
      } else {
        /* Continuing gap */
        gapOccupancySum += channelData[ch];
      }
    } else {
      if (inGap) {
        /* End of gap */
        uint8_t gapWidth = ch - gapStart;
        if (gapWidth >= MIN_GAP_WIDTH && numGaps < MAX_GAPS) {
          gaps[numGaps].start = gapStart;
          gaps[numGaps].end = ch - 1;
          gaps[numGaps].width = gapWidth;
          gaps[numGaps].avgOccupancy = (uint8_t)(gapOccupancySum / gapWidth);
          gaps[numGaps].channelsAssigned = 0;
          numGaps++;
        }
        inGap = false;
        gapOccupancySum = 0;
      }
    }
  }
  
  /* Handle gap that extends to the end */
  if (inGap) {
    uint8_t gapWidth = NUM_CHANNELS - gapStart;
    if (gapWidth >= MIN_GAP_WIDTH && numGaps < MAX_GAPS) {
      gaps[numGaps].start = gapStart;
      gaps[numGaps].end = NUM_CHANNELS - 1;
      gaps[numGaps].width = gapWidth;
      gaps[numGaps].avgOccupancy = (uint8_t)(gapOccupancySum / gapWidth);
      gaps[numGaps].channelsAssigned = 0;
      numGaps++;
    }
  }
  
  if (numGaps == 0) {
    /* No suitable gaps found - fall back to lowest occupancy channels with spacing */
    return 0;  /* Will be handled by fallback below */
  }
  
  /* Step 2: Calculate total usable spectrum (sum of all gap widths) */
  uint16_t totalUsableSpectrum = 0;
  for (uint8_t i = 0; i < numGaps; i++) {
    totalUsableSpectrum += gaps[i].width;
  }
  
  /* Step 3: Distribute channels across gaps proportionally to their width */
  uint8_t channelsRemaining = numRecommendations;
  
  for (uint8_t i = 0; i < numGaps && channelsRemaining > 0; i++) {
    /* Calculate proportional share: (gap_width / total_width) * total_channels */
    uint8_t proportionalShare = (gaps[i].width * numRecommendations) / totalUsableSpectrum;

    /* Ensure at least 1 channel if there's room and channels remaining */
    if (proportionalShare == 0 && channelsRemaining > 0) {
      proportionalShare = 1;
    }
    
    /* Don't assign more than what's left */
    if (proportionalShare > channelsRemaining) {
      proportionalShare = channelsRemaining;
    }
    
    /* Don't assign more than what fits with spacing */
    uint8_t maxFit = (gaps[i].width + MIN_CHANNEL_SPACING - 1) / MIN_CHANNEL_SPACING;
    if (proportionalShare > maxFit) {
      proportionalShare = maxFit;
    }
    
    gaps[i].channelsAssigned = proportionalShare;
    channelsRemaining -= proportionalShare;
  }
  
  /* Step 4: Distribute any remaining channels to gaps with room */
  /* This handles rounding issues from integer division */
  while (channelsRemaining > 0) {
    bool assigned = false;
    
    /* Try to assign to gaps that have room and fewer channels than they could hold */
    for (uint8_t i = 0; i < numGaps && channelsRemaining > 0; i++) {
      uint8_t maxFit = (gaps[i].width + MIN_CHANNEL_SPACING - 1) / MIN_CHANNEL_SPACING;
      if (gaps[i].channelsAssigned < maxFit) {
        gaps[i].channelsAssigned++;
        channelsRemaining--;
        assigned = true;
      }
    }
    
    /* If no gap has room, break to avoid infinite loop */
    if (!assigned) {
      break;
    }
  }
  
  /* Step 5: Place channels within each gap, distributed evenly */
  uint8_t numRecommended = 0;

  for (uint8_t g = 0; g < numGaps && numRecommended < numRecommendations; g++) {
    uint8_t channelsInGap = gaps[g].channelsAssigned;
    
    if (channelsInGap == 0) continue;
    
    /* Distribute channels evenly within the gap */
    for (uint8_t i = 0; i < channelsInGap; i++) {
      /* Calculate position: spread evenly across gap width */
      /* Formula: start + (i + 0.5) * width / channelsInGap */
      uint8_t position = gaps[g].start + ((2 * i + 1) * gaps[g].width) / (2 * channelsInGap);
      
      /* Clamp to gap boundaries */
      if (position < gaps[g].start) position = gaps[g].start;
      if (position > gaps[g].end) position = gaps[g].end;
      
      recommendedChannels[numRecommended] = position;
      numRecommended++;

      if (numRecommended >= numRecommendations) break;
    }
  }
  
  /* Step 6: If we didn't find enough channels in gaps, fall back to lowest occupancy */
  if (numRecommended < numRecommendations) {
    /* Create a sorted list of channels by occupancy */
    for (uint8_t ch = 0; ch < NUM_CHANNELS && numRecommended < numRecommendations; ch++) {
      /* Find the channel with lowest occupancy that's not already recommended */
      uint8_t bestCh = 255;
      uint8_t bestOccupancy = 255;

      for (uint8_t candidate = 0; candidate < NUM_CHANNELS; candidate++) {
        /* Check if already recommended */
        bool alreadyRecommended = false;
        for (uint8_t i = 0; i < numRecommended; i++) {
          if (recommendedChannels[i] == candidate) {
            alreadyRecommended = true;
            break;
          }
        }
        
        if (alreadyRecommended) continue;
        
        /* Check spacing from existing recommendations */
        bool goodSpacing = true;
        for (uint8_t i = 0; i < numRecommended; i++) {
          int16_t distance = (int16_t)candidate - (int16_t)recommendedChannels[i];
          if (distance < 0) distance = -distance;
          if (distance < MIN_CHANNEL_SPACING) {
            goodSpacing = false;
            break;
          }
        }
        
        if (!goodSpacing) continue;
        
        /* Check if this is the best candidate so far */
        if (channelData[candidate] < bestOccupancy) {
          bestOccupancy = channelData[candidate];
          bestCh = candidate;
        }
      }
      
      /* If we found a valid channel, add it */
      if (bestCh != 255) {
        recommendedChannels[numRecommended] = bestCh;
        numRecommended++;
      } else {
        /* No more valid channels available */
        break;
      }
    }
  }
  
  return numRecommended;
}

static void PrintChannelScanResults(const McuShell_StdIOType *io, uint8_t *channelData, uint8_t numChannels) {
  unsigned char buf[128];
  uint8_t bestChannel = 0;
  uint8_t lowestOccupancy = 255;
  
  /* Get channel recommendations first so we can mark them in the graph */
  #define NUM_RECOMMENDATIONS 5
  uint8_t recommendedChannels[NUM_RECOMMENDATIONS];
  uint8_t numRecommended = FindRecommendedChannels(NUM_RECOMMENDATIONS, channelData, recommendedChannels);

  uint8_t recommendedOccupancy[NUM_RECOMMENDATIONS];
  for (uint8_t i = 0; i < numRecommended; i++) {
    recommendedOccupancy[i] = channelData[recommendedChannels[i]];
  }
  
  McuShell_SendStr((unsigned char*)"\r\n2.4 GHz Spectrum Analysis\r\n", io->stdOut);
  McuShell_SendStr((unsigned char*)"Ch  Freq  Use |0%         25%         50%         75%        100%|\r\n", io->stdOut);
  McuShell_SendStr((unsigned char*)"Nr  MHz   (%) |                                                  |\r\n", io->stdOut);
  McuShell_SendStr((unsigned char*)"------------------------------------------------------------------\r\n", io->stdOut);
  
  for (uint8_t ch = 0; ch < numChannels; ch++) {
    /* Calculate frequency: 2400 + channel MHz */
    uint16_t freq = 2400 + ch;
    
    /* Channel number (3 chars, right-aligned) */
    if (ch < 10) {
      McuUtility_strcpy(buf, sizeof(buf), (unsigned char*)"  ");
    } else if (ch < 100) {
      McuUtility_strcpy(buf, sizeof(buf), (unsigned char*)" ");
    } else {
      McuUtility_strcpy(buf, sizeof(buf), (unsigned char*)"");
    }
    McuUtility_strcatNum8u(buf, sizeof(buf), ch);
    McuUtility_strcat(buf, sizeof(buf), (unsigned char*)" ");
    
    /* Frequency (4 digits) */
    McuUtility_strcatNum16u(buf, sizeof(buf), freq);
    McuUtility_strcat(buf, sizeof(buf), (unsigned char*)" ");
    
    /* Occupancy percentage (3 chars, right-aligned) */
    if (channelData[ch] < 10) {
      McuUtility_strcat(buf, sizeof(buf), (unsigned char*)"   ");
    } else if (channelData[ch] < 100) {
      McuUtility_strcat(buf, sizeof(buf), (unsigned char*)"  ");
    } else {
      McuUtility_strcat(buf, sizeof(buf), (unsigned char*)" ");
    }
    McuUtility_strcatNum8u(buf, sizeof(buf), channelData[ch]);
    McuUtility_strcat(buf, sizeof(buf), (unsigned char*)" |");
    
    /* Draw bar graph - scale to 50 characters wide (0-100% = 0-50 chars) */
    /* Round up: add 99 before dividing so even 1% shows at least one bar */
    uint8_t barLength;
    if (channelData[ch] > 0) {
      barLength = ((channelData[ch] * 50) + 99) / 100;  /* Round up */
      if (barLength > 50) barLength = 50;  /* Cap at max width */
    } else {
      barLength = 0;
    }
    
    for (uint8_t i = 0; i < barLength; i++) {
      McuUtility_strcat(buf, sizeof(buf), (unsigned char*)"#");
    }
    
    /* Fill remaining space with spaces to reach right edge */
    for (uint8_t i = barLength; i < 50; i++) {
      McuUtility_strcat(buf, sizeof(buf), (unsigned char*)" ");
    }
    
    /* Add right edge to frame the graph */
    McuUtility_strcat(buf, sizeof(buf), (unsigned char*)"|");
    
    /* Check if this channel is recommended and add arrow marker */
    bool isRecommended = false;
    for (uint8_t i = 0; i < numRecommended; i++) {
      if (recommendedChannels[i] == ch) {
        isRecommended = true;
        break;
      }
    }
    
    if (isRecommended) {
      McuUtility_strcat(buf, sizeof(buf), (unsigned char*)" <--");
    }
    
    McuUtility_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
    McuShell_SendStr(buf, io->stdOut);
  }
  McuShell_SendStr((unsigned char*)"------------------------------------------------------------------\r\n", io->stdOut);
  
  /* Show recommendations */
  McuShell_SendStr((unsigned char*)"\r\nRecommended Channels (distributed across quiet gaps):\r\n", io->stdOut);
  for (uint8_t i = 0; i < numRecommended; i++) {
    McuUtility_strcpy(buf, sizeof(buf), (unsigned char*)"  ");
    McuUtility_strcatNum8u(buf, sizeof(buf), i + 1);
    McuUtility_strcat(buf, sizeof(buf), (unsigned char*)". Channel ");
    McuUtility_strcatNum8u(buf, sizeof(buf), recommendedChannels[i]);
    McuUtility_strcat(buf, sizeof(buf), (unsigned char*)" (");
    McuUtility_strcatNum16u(buf, sizeof(buf), 2400 + recommendedChannels[i]);
    McuUtility_strcat(buf, sizeof(buf), (unsigned char*)" MHz) - ");
    McuUtility_strcatNum8u(buf, sizeof(buf), recommendedOccupancy[i]);
    McuUtility_strcat(buf, sizeof(buf), (unsigned char*)"% occupied\r\n");
    McuShell_SendStr(buf, io->stdOut);
  }
  
  if (numRecommended == 0) {
    McuShell_SendStr((unsigned char*)"  No suitable channels found (all heavily occupied)\r\n", io->stdOut);
  }
}

static uint8_t ScanAndReportChannels(const McuShell_StdIOType *io) {
  uint8_t channelData[McuNRF24L01_NUM_CHANNELS];
  uint8_t res;

  McuShell_SendStr((unsigned char*)"Starting channel scan...\r\n", io->stdOut);
  res = ScanChannels(channelData, McuNRF24L01_NUM_CHANNELS);
  if (res == ERR_OK) {
    PrintChannelScanResults(io, channelData, McuNRF24L01_NUM_CHANNELS);
  } else {
    McuShell_SendStr((unsigned char*)"Channel scan failed!\r\n", io->stdErr);
    return res;
  }
  return ERR_OK;
}

static uint8_t PrintHelp(const McuShell_StdIOType *io) {
  McuShell_SendHelpStr((unsigned char*)"McuNRF", (unsigned char*)"Group of nRF24L01+ commands\r\n", io->stdOut);
  McuShell_SendHelpStr((unsigned char*)"  help|status", (unsigned char*)"Shows help or status\r\n", io->stdOut);
  McuShell_SendHelpStr((unsigned char*)"  scan", (unsigned char*)"Scan all 2.4GHz channels for interference\r\n", io->stdOut);
  return ERR_OK;
}

static uint8_t PrintStatus(const McuShell_StdIOType *io) {
  uint8_t buf[64];

  McuShell_SendStatusStr((unsigned char*)"McuNRF", (unsigned char*)"nRF24L01+ status\r\n", io->stdOut);

  McuGPIO_GetPinStatusString(cePin, buf, sizeof(buf));
  McuUtility_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  McuShell_SendStatusStr((const unsigned char*)"  CE", (const unsigned char*)buf, io->stdOut);

  McuGPIO_GetPinStatusString(csnPin, buf, sizeof(buf));
  McuUtility_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  McuShell_SendStatusStr((const unsigned char*)"  CSN", (const unsigned char*)buf, io->stdOut);
#if McuNRF24L01_CONFIG_USE_MUTEX
  McuShell_SendStatusStr((const unsigned char*)"  mutex", (const unsigned char*)"yes (SPI)\r\n", io->stdOut);
#else
  McuShell_SendStatusStr((const unsigned char*)"  mutex", (const unsigned char*)"no (SPI)\r\n", io->stdOut);
#endif
  return ERR_OK;
}

uint8_t McuNRF24L01_ParseCommand(const unsigned char *cmd, bool *handled, const McuShell_StdIOType *io) {
  uint8_t res = ERR_OK;

  if (McuUtility_strcmp((char*)cmd, (char*)McuShell_CMD_HELP)==0 || McuUtility_strcmp((char*)cmd, (char*)"McuNRF help")==0) {
    *handled = TRUE;
    return PrintHelp(io);
  } else if (McuUtility_strcmp((char*)cmd, (char*)McuShell_CMD_STATUS)==0 || McuUtility_strcmp((char*)cmd, (char*)"McuNRF status")==0) {
    *handled = TRUE;
    return PrintStatus(io);
  } else if (McuUtility_strcmp((char*)cmd, (char*)"McuNRF scan")==0) {
    *handled = TRUE;
    return ScanAndReportChannels(io);
  }
  return res;
}

#endif /* McuNRF24L01_CONFIG_IS_ENABLED */

/* END McuNRF24L01. */

/*!
** @}
*/
